<!DOCTYPE html>
<html lang="es">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxia de Amor con Saturno</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600;700&family=Dancing+Script:wght@700&family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: radial-gradient(ellipse at bottom, #0a0e1a 0%, #000000 100%);
            color: white;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        h2 {
            color: #ff69b4;
            font-size: 1.5rem;
        }

        .cielo {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .estrella {
            position: absolute;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 2px white;
            animation: centellear var(--duracion) infinite alternate ease-in-out var(--retraso);
            z-index: 0;
        }

        @keyframes centellear {

            0%,
            100% {
                opacity: 0.5;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        .luna {
            position: absolute;
            /* Cambiado de fixed a absolute */
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border-radius: 50%;
            box-shadow: 0 0 60px rgba(255, 255, 255, 0.8),
                inset -10px -10px 20px rgba(0, 0, 0, 0.2);
            opacity: 0.8;
            transition: left 0.1s ease-out, top 0.1s ease-out, opacity 0.3s ease;
            pointer-events: none;
            z-index: 5;
            transform: translate(-50%, -50%);
            /* Para centrar la luna en las coordenadas */
        }

        #contenedor-escena {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
        }

        #superposicion-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        #instrucciones {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 16px;
            padding: 12px;
            animation: pulso 3s infinite;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }

        @keyframes pulso {
            0% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        .corazon {
            position: absolute;
            font-size: 22px;
            color: #ff69b4;
            z-index: 5;
            pointer-events: none;
            animation: caer linear forwards;
            text-shadow: 0 0 8px #ff1493;
        }

        @keyframes caer {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        #indicador-toque {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 105, 180, 0.7) 0%, rgba(255, 20, 147, 0) 70%);
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transform: translate(-50%, -50%);
        }

        #cargando {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            z-index: 100;
            background: radial-gradient(circle at center, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            backdrop-filter: blur(5px);
            color: #fff;
        }

        .contenido-cargando {
            background: rgba(0, 0, 0, 0.6);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(100, 149, 237, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .cargador-reloj {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            position: relative;
            margin: 20px auto;
            background: conic-gradient(#ff69b4 0%, #ff69b4 var(--progreso, 0%), #4a4a8a var(--progreso, 0%), #4a4a8a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
        }

        .cargador-reloj::before {
            content: '';
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #1a1a2e;
        }

        .manecilla-reloj {
            position: absolute;
            width: 3px;
            height: 30px;
            background: #ff69b4;
            top: 10px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            box-shadow: 0 0 5px #ff69b4;
            z-index: 1;
            animation: rotar-reloj 2s linear infinite;
        }

        @keyframes rotar-reloj {
            0% {
                transform: translateX(-50%) rotate(0deg);
            }

            100% {
                transform: translateX(-50%) rotate(360deg);
            }
        }

        .centro-reloj {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff69b4;
            z-index: 2;
            box-shadow: 0 0 10px #ff69b4;
        }

        .texto-progreso {
            margin-top: 10px;
            font-size: 18px;
            color: #ff69b4;
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.7);
        }

        #alternar-audio {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 15;
            font-size: 14px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            transition: all 0.3s ease;
            opacity: 0.8;
        }

        #alternar-audio:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.25);
        }

        .galeria {
            position: absolute;
            bottom: 80px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 0 10px;
            z-index: 15;
            pointer-events: auto;
        }

        .elemento-galeria {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .elemento-galeria:hover {
            transform: scale(1.1);
            border-color: #ff69b4;
        }

        .elemento-galeria img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .contenido-modal {
            max-width: 90%;
            max-height: 80%;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.5);
        }

        .mensaje-modal {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 20px;
            color: #ff69b4;
            text-shadow: 0 0 10px #ff1493;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        .boton-cerrar {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 40px;
            color: white;
            cursor: pointer;
            z-index: 101;
        }

        @keyframes animacionExplosionTexto {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3);
            }
        }

        @media (max-width: 768px) {
            .luna {
                width: 100px;
                height: 100px;
            }

            #instrucciones {
                font-size: 14px;
                padding: 10px;
            }
        }
    </style>
</head>

<body>
    <div class="cielo" id="cielo-estrellas">
        <div class="luna"></div>
    </div>

    <div id="cargando">
        <div class="contenido-cargando">
            <h2>Preparando todo para ti, mi ni침a hermosa仇벒잺</h2>
            <div class="cargador-reloj" id="cargador-reloj" style="--progreso: 0%;">
                <div class="manecilla-reloj"></div>
                <div class="centro-reloj"></div>
            </div>
            <div class="texto-progreso" id="texto-progreso">0%</div>
        </div>
    </div>

    <div id="contenedor-escena"></div>

    <div id="superposicion-ui">
        <button id="alternar-audio">游댉</button>
        <div id="indicador-toque"></div>
        <div id="instrucciones">Toca la pantalla mi piciosa仇벒잺</div>
    </div>

    <div id="modal-imagen" class="modal">
        <span class="boton-cerrar">칑</span>
        <div class="contenido-modal" id="imagen-modal"
            style="background: linear-gradient(45deg, #ff69b4, #ff1493); padding: 50px; border-radius: 15px; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 20px;">仇벒잺</div>
            <div style="font-size: 24px; color: white;">Mi Amor Eterno</div>
        </div>
        <div class="mensaje-modal" id="mensaje-modal">Eres la luz que ilumina mi vida cada d칤a</div>
    </div>

    <audio id="audio-fondo" loop preload="auto">
        <source src="saturno.mp3" type="audio/mpeg">
    </audio>

    <script>
        // OrbitControls implementation
        (function () {
            const _changeEvent = { type: 'change' };
            const _startEvent = { type: 'start' };
            const _endEvent = { type: 'end' };

            class OrbitControls extends THREE.EventDispatcher {
                constructor(object, domElement) {
                    super();
                    this.object = object;
                    this.domElement = domElement;
                    this.enabled = true;
                    this.target = new THREE.Vector3();
                    this.minDistance = 0;
                    this.maxDistance = Infinity;
                    this.minZoom = 0;
                    this.maxZoom = Infinity;
                    this.minPolarAngle = 0;
                    this.maxPolarAngle = Math.PI;
                    this.minAzimuthAngle = -Infinity;
                    this.maxAzimuthAngle = Infinity;
                    this.enableDamping = false;
                    this.dampingFactor = 0.05;
                    this.enableZoom = true;
                    this.zoomSpeed = 1.0;
                    this.enableRotate = true;
                    this.rotateSpeed = 1.0;
                    this.enablePan = true;
                    this.panSpeed = 1.0;
                    this.screenSpacePanning = true;
                    this.keyPanSpeed = 7.0;
                    this.autoRotate = false;
                    this.autoRotateSpeed = 2.0;

                    this.keys = {
                        LEFT: 'ArrowLeft',
                        UP: 'ArrowUp',
                        RIGHT: 'ArrowRight',
                        BOTTOM: 'ArrowDown'
                    };

                    this.mouseButtons = {
                        LEFT: THREE.MOUSE.ROTATE,
                        MIDDLE: THREE.MOUSE.DOLLY,
                        RIGHT: THREE.MOUSE.PAN
                    };

                    this.touches = {
                        ONE: THREE.TOUCH.ROTATE,
                        TWO: THREE.TOUCH.DOLLY_PAN
                    };

                    this.target0 = this.target.clone();
                    this.position0 = this.object.position.clone();
                    this.zoom0 = this.object.zoom;

                    const scope = this;
                    const STATE = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    };

                    let state = STATE.NONE;
                    const EPS = 0.000001;
                    const spherical = new THREE.Spherical();
                    const sphericalDelta = new THREE.Spherical();
                    let scale = 1;
                    const panOffset = new THREE.Vector3();
                    let zoomChanged = false;

                    const rotateStart = new THREE.Vector2();
                    const rotateEnd = new THREE.Vector2();
                    const rotateDelta = new THREE.Vector2();

                    const panStart = new THREE.Vector2();
                    const panEnd = new THREE.Vector2();
                    const panDelta = new THREE.Vector2();

                    const dollyStart = new THREE.Vector2();
                    const dollyEnd = new THREE.Vector2();
                    const dollyDelta = new THREE.Vector2();

                    this.update = function () {
                        const offset = new THREE.Vector3();
                        const quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                        const quatInverse = quat.clone().invert();
                        const lastPosition = new THREE.Vector3();
                        const lastQuaternion = new THREE.Quaternion();
                        const twoPI = 2 * Math.PI;

                        return function update() {
                            const position = scope.object.position;
                            offset.copy(position).sub(scope.target);
                            offset.applyQuaternion(quat);
                            spherical.setFromVector3(offset);

                            if (scope.autoRotate && state === STATE.NONE) {
                                rotateLeft(getAutoRotationAngle());
                            }

                            if (scope.enableDamping) {
                                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                                spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                            } else {
                                spherical.theta += sphericalDelta.theta;
                                spherical.phi += sphericalDelta.phi;
                            }

                            let min = scope.minAzimuthAngle;
                            let max = scope.maxAzimuthAngle;

                            if (isFinite(min) && isFinite(max)) {
                                if (min < -Math.PI) min += twoPI;
                                else if (min > Math.PI) min -= twoPI;
                                if (max < -Math.PI) max += twoPI;
                                else if (max > Math.PI) max -= twoPI;

                                if (min <= max) {
                                    spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                                } else {
                                    spherical.theta = spherical.theta > (min + max) / 2 ?
                                        Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
                                }
                            }

                            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                            spherical.makeSafe();
                            spherical.radius *= scale;
                            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

                            if (scope.enableDamping === true) {
                                scope.target.addScaledVector(panOffset, scope.dampingFactor);
                            } else {
                                scope.target.add(panOffset);
                            }

                            offset.setFromSpherical(spherical);
                            offset.applyQuaternion(quatInverse);
                            position.copy(scope.target).add(offset);
                            scope.object.lookAt(scope.target);

                            if (scope.enableDamping === true) {
                                sphericalDelta.theta *= 1 - scope.dampingFactor;
                                sphericalDelta.phi *= 1 - scope.dampingFactor;
                                panOffset.multiplyScalar(1 - scope.dampingFactor);
                            } else {
                                sphericalDelta.set(0, 0, 0);
                                panOffset.set(0, 0, 0);
                            }

                            scale = 1;

                            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS ||
                                8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                                scope.dispatchEvent(_changeEvent);
                                lastPosition.copy(scope.object.position);
                                lastQuaternion.copy(scope.object.quaternion);
                                zoomChanged = false;
                                return true;
                            }

                            return false;
                        };
                    }();

                    function getAutoRotationAngle() {
                        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
                    }

                    function rotateLeft(angle) {
                        sphericalDelta.theta -= angle;
                    }

                    function rotateUp(angle) {
                        sphericalDelta.phi -= angle;
                    }

                    function dollyOut(dollyScale) {
                        if (scope.object.isPerspectiveCamera) {
                            scale /= dollyScale;
                        } else if (scope.object.isOrthographicCamera) {
                            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
                            scope.object.updateProjectionMatrix();
                            zoomChanged = true;
                        }
                    }

                    function dollyIn(dollyScale) {
                        if (scope.object.isPerspectiveCamera) {
                            scale *= dollyScale;
                        } else if (scope.object.isOrthographicCamera) {
                            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
                            scope.object.updateProjectionMatrix();
                            zoomChanged = true;
                        }
                    }

                    function handleMouseDownRotate(event) {
                        rotateStart.set(event.clientX, event.clientY);
                    }

                    function handleMouseDownDolly(event) {
                        dollyStart.set(event.clientX, event.clientY);
                    }

                    function handleMouseMoveRotate(event) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
                        const element = scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
                        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
                        rotateStart.copy(rotateEnd);
                        scope.update();
                    }

                    function handleMouseMoveDolly(event) {
                        dollyEnd.set(event.clientX, event.clientY);
                        dollyDelta.subVectors(dollyEnd, dollyStart);
                        if (dollyDelta.y > 0) {
                            dollyOut(getZoomScale());
                        } else if (dollyDelta.y < 0) {
                            dollyIn(getZoomScale());
                        }
                        dollyStart.copy(dollyEnd);
                        scope.update();
                    }

                    function handleMouseWheel(event) {
                        if (event.deltaY < 0) {
                            dollyIn(getZoomScale());
                        } else if (event.deltaY > 0) {
                            dollyOut(getZoomScale());
                        }
                        scope.update();
                    }

                    function getZoomScale() {
                        return Math.pow(0.95, scope.zoomSpeed);
                    }

                    function onMouseDown(event) {
                        if (scope.enabled === false) return;
                        event.preventDefault();

                        switch (event.button) {
                            case 0:
                                if (scope.enableRotate === false) return;
                                handleMouseDownRotate(event);
                                state = STATE.ROTATE;
                                break;
                            case 1:
                                if (scope.enableZoom === false) return;
                                handleMouseDownDolly(event);
                                state = STATE.DOLLY;
                                break;
                        }

                        if (state !== STATE.NONE) {
                            scope.domElement.ownerDocument.addEventListener('mousemove', onMouseMove);
                            scope.domElement.ownerDocument.addEventListener('mouseup', onMouseUp);
                            scope.dispatchEvent(_startEvent);
                        }
                    }

                    function onMouseMove(event) {
                        if (scope.enabled === false) return;
                        event.preventDefault();

                        switch (state) {
                            case STATE.ROTATE:
                                if (scope.enableRotate === false) return;
                                handleMouseMoveRotate(event);
                                break;
                            case STATE.DOLLY:
                                if (scope.enableZoom === false) return;
                                handleMouseMoveDolly(event);
                                break;
                        }
                    }

                    function onMouseUp() {
                        if (scope.enabled === false) return;
                        scope.domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);
                        scope.domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);
                        scope.dispatchEvent(_endEvent);
                        state = STATE.NONE;
                    }

                    function onMouseWheel(event) {
                        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
                        event.preventDefault();
                        event.stopPropagation();
                        scope.dispatchEvent(_startEvent);
                        handleMouseWheel(event);
                        scope.dispatchEvent(_endEvent);
                    }

                    this.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
                    this.domElement.addEventListener('mousedown', onMouseDown);
                    this.domElement.addEventListener('wheel', onMouseWheel, { passive: false });

                    this.update();
                }
            }

            THREE.OrbitControls = OrbitControls;
        })();

        let escena, camara, renderizador, saturno, controles;
        let lluviaCorazonesActiva = false, contadorToques = 0;
        let objetosMensaje = [];
        let objetosTextoAnillo = [];
        let audioHabilitado = false;
        let audioReproducido = false;

        const textoAnillo = "TE AMO CON TODO MI CORAZ칍N Y ALMA PARA SIEMPRE MI AMOR ETERNO";

        const mensajesAmor = [
            "TE AMO", "TE QUIERO", "MI REINA", "MI AMOR", "ERES 칔NICA", "PARA SIEMPRE", "MI VIDA", "MI CORAZ칍N", "MI ALMA", "MI LUZ", "MI RAZ칍N", "MI FELICIDAD", "MI SUE칌O", "MI DESEO", "MI PASI칍N", "MI TESORO", "MI 츼NGEL", "MI SOL", "MI ESTRELLA", "MI DESTINO", "MI TODO", "MI VIDA ENTERA", "MI PRINCESA", "MI REINA HERMOSA", "MI COMPLEMENTO", "MI MUNDO", "MI PERSONA FAVORITA", "MI INSPIRACI칍N", "MI ALEGR칈A", "MI REFUGIO", "MI AMOR BONITO", "MI LOCURA LINDA", "MI ADICCI칍N", "MI ILUSI칍N", "MI COMPLICIDAD", "MI CIELO", "MI LATIDO", "MI POES칈A", "MI RESPIRACI칍N", "MI TODO EN UNO", "MI ABRAZO FAVORITO", "MI CARICIA PERFECTA", "MI VERDAD", "MI SUE칌O HECHO REALIDAD", "MI FINAL FELIZ", "MI MILAGRO", "MI PRESENTE Y FUTURO", "MI HOGAR", "MI ENAMORADA ETERNA", "MI CANCI칍N FAVORITA", "MI DESTINO PERFECTO", "MI VIDA CONTIGO", "MI HISTORIA DE AMOR", "MI LUGAR SEGURO", "MI TODO LO BONITO", "MI AMOR DE CINE", "MI RAZ칍N DE SONRE칈R", "MI VERSO M츼S BELLO", "MI AMOR ETERNO", "MI MUSA", "MI PASADO, PRESENTE Y FUTURO"
        ];

        const mensajesImagen = [
            "Eres la luz que ilumina mi vida cada d칤a",
            "Cada momento a tu lado es un regalo del universo",
            "Tu sonrisa es mi mayor tesoro",
            "Contigo he encontrado el amor verdadero"
        ];

        function crearEstrellasCSS(cantidad) {
            const cielo = document.getElementById('cielo-estrellas');
            for (let i = 0; i < cantidad; i++) {
                const estrella = document.createElement('div');
                estrella.classList.add('estrella');
                const tama침o = Math.random() * 2 + 1;
                estrella.style.width = tama침o + 'px';
                estrella.style.height = tama침o + 'px';
                estrella.style.left = Math.random() * 100 + 'vw';
                estrella.style.top = Math.random() * 100 + 'vh';
                estrella.style.setProperty('--retraso', Math.random() * 5 + 's');
                estrella.style.setProperty('--duracion', (Math.random() * 4 + 2) + 's');
                cielo.appendChild(estrella);
            }
        }

        function simularCarga() {
            const cargadorReloj = document.getElementById('cargador-reloj');
            const textoProgreso = document.getElementById('texto-progreso');
            let progreso = 0;

            const intervalo = setInterval(() => {
                progreso += 2;
                if (progreso <= 100) {
                    cargadorReloj.style.setProperty('--progreso', progreso + '%');
                    textoProgreso.textContent = progreso + '%';
                } else {
                    clearInterval(intervalo);
                }
            }, 50);
        }

        function inicializar() {
            simularCarga();

            setTimeout(() => {
                document.getElementById('cargando').style.display = 'none';

                escena = new THREE.Scene();
                escena.background = null;

                camara = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camara.position.set(0, 8, 30);

                renderizador = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderizador.setSize(window.innerWidth, window.innerHeight);
                renderizador.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderizador.shadowMap.enabled = true;
                renderizador.shadowMap.type = THREE.PCFSoftShadowMap;
                renderizador.toneMapping = THREE.ACESFilmicToneMapping;
                renderizador.toneMappingExposure = 1.2;
                renderizador.setClearColor(0x000000, 0);

                document.getElementById('contenedor-escena').appendChild(renderizador.domElement);

                controles = new THREE.OrbitControls(camara, renderizador.domElement);
                controles.enableDamping = true;
                controles.dampingFactor = 0.05;
                controles.rotateSpeed = 0.5;
                controles.enableZoom = true;
                controles.zoomSpeed = 1.0;
                controles.autoRotate = true;
                controles.autoRotateSpeed = 0.2;
                controles.minDistance = 10;
                controles.maxDistance = 80;
                controles.minPolarAngle = 0;
                controles.maxPolarAngle = Math.PI;

                // Iluminaci칩n
                const luzAmbiental = new THREE.AmbientLight(0x444477, 0.4);
                escena.add(luzAmbiental);

                const luzDireccional = new THREE.DirectionalLight(0xffffff, 1.5);
                luzDireccional.position.set(10, 10, 5);
                luzDireccional.castShadow = true;
                escena.add(luzDireccional);

                const luzPunto = new THREE.PointLight(0xff69b4, 0.6, 50);
                luzPunto.position.set(0, 0, 10);
                escena.add(luzPunto);

                crearSaturno();
                crearAnilloTexto();
                crearCampoEstrellas();
                crearMensajesAmor();
                crearParticulasFlotantes();

                configurarEventos();
                animar();
            }, 3000);
        }

        function crearSaturno() {
            // Crear geometr칤a de Saturno
            const geometria = new THREE.SphereGeometry(4, 64, 64);

            // Cargar la textura desde el archivo
            const cargadorTextura = new THREE.TextureLoader();
            const textura = cargadorTextura.load('textura_saturno.jpg');

            const material = new THREE.MeshPhongMaterial({
                map: textura,
                shininess: 30,
                transparent: true,
                opacity: 0.9
            });

            saturno = new THREE.Mesh(geometria, material);
            saturno.castShadow = true;
            saturno.receiveShadow = true;
            escena.add(saturno);

            // Crear anillos de Saturno
            const geometriaAnillo1 = new THREE.RingGeometry(4.8, 5.2, 64);
            const materialAnillo1 = new THREE.MeshPhongMaterial({
                color: 0xffccff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4,
                emissive: 0x330022
            });
            const anillo1 = new THREE.Mesh(geometriaAnillo1, materialAnillo1);
            anillo1.rotation.x = Math.PI / 2 + 0.1;
            escena.add(anillo1);

            const geometriaAnillo2 = new THREE.RingGeometry(5.5, 6.2, 64);
            const materialAnillo2 = new THREE.MeshPhongMaterial({
                color: 0xddaaff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3,
                emissive: 0x220011
            });
            const anillo2 = new THREE.Mesh(geometriaAnillo2, materialAnillo2);
            anillo2.rotation.x = Math.PI / 2 + 0.1;
            escena.add(anillo2);

            const geometriaAnillo3 = new THREE.RingGeometry(6.5, 7.2, 64);
            const materialAnillo3 = new THREE.MeshPhongMaterial({
                color: 0xccaadd,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.2,
                emissive: 0x110022
            });
            const anillo3 = new THREE.Mesh(geometriaAnillo3, materialAnillo3);
            anillo3.rotation.x = Math.PI / 2 + 0.1;
            escena.add(anillo3);

            // Crear atm칩sfera
            const geometriaAtmosfera = new THREE.SphereGeometry(4.15, 32, 32);
            const materialAtmosfera = new THREE.MeshPhongMaterial({
                color: 0x88aaff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const atmosfera = new THREE.Mesh(geometriaAtmosfera, materialAtmosfera);
            saturno.add(atmosfera);
        }

        function crearAnilloTexto() {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/gentilis_bold.typeface.json', function (fuente) {

                const radio = 9;
                const totalLetras = textoAnillo.length;
                const pasoAngulo = (Math.PI * 2) / totalLetras;

                for (let i = 0; i < totalLetras; i++) {
                    const letra = textoAnillo[i];
                    if (letra === ' ') continue;

                    const geometriaTexto = new THREE.TextGeometry(letra, {
                        font: fuente,
                        size: 0.6,
                        height: 0.2,
                        curveSegments: 8,
                        bevelEnabled: false
                    });

                    geometriaTexto.center();

                    const materialTexto = new THREE.MeshPhongMaterial({
                        color: 0xffccff,
                        emissive: 0x550044,
                        transparent: true,
                        opacity: 0.9
                    });

                    const mallaTexto = new THREE.Mesh(geometriaTexto, materialTexto);

                    // Posicionar letra en el c칤rculo (invertido para lectura correcta)
                    const angulo = -i * pasoAngulo; // Negativo para invertir direcci칩n
                    mallaTexto.position.x = Math.cos(angulo) * radio;
                    mallaTexto.position.z = Math.sin(angulo) * radio;
                    mallaTexto.position.y = Math.sin(angulo * 3) * 0.5;

                    // Rotar la letra para que mire hacia afuera y est칠 orientada correctamente
                    mallaTexto.lookAt(0, mallaTexto.position.y, 0);
                    mallaTexto.rotateY(Math.PI);

                    escena.add(mallaTexto);
                    objetosTextoAnillo.push(mallaTexto);
                }
            });
        }

        function crearCampoEstrellas() {
            const geometriaEstrellas = new THREE.BufferGeometry();
            const materialEstrellas = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                sizeAttenuation: true
            });

            const verticesEstrellas = [];
            const colores = [];

            for (let i = 0; i < 2000; i++) {
                verticesEstrellas.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );

                // Colores variados para las estrellas
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.75);
                colores.push(color.r, color.g, color.b);
            }

            geometriaEstrellas.setAttribute('position', new THREE.Float32BufferAttribute(verticesEstrellas, 3));
            geometriaEstrellas.setAttribute('color', new THREE.Float32BufferAttribute(colores, 3));

            materialEstrellas.vertexColors = true;

            const campoEstrellas = new THREE.Points(geometriaEstrellas, materialEstrellas);
            escena.add(campoEstrellas);
        }

        function crearMensajesAmor() {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/gentilis_bold.typeface.json', function (fuente) {

                // Barajar mensajes y tomar 30
                const mensajesMezclados = [...mensajesAmor].sort(() => Math.random() - 0.5);
                const mensajesAUsar = mensajesMezclados.slice(0, 30);

                mensajesAUsar.forEach((mensaje, i) => {
                    // Crear geometr칤a de texto con todo el mensaje
                    const geometriaTexto = new THREE.TextGeometry(mensaje, {
                        font: fuente,
                        size: 0.6,
                        height: 0.2,
                        curveSegments: 8,
                        bevelEnabled: false
                    });

                    geometriaTexto.center(); // centrar el texto en su eje

                    const materialTexto = new THREE.MeshStandardMaterial({
                        color: 0xff69b4,
                        emissive: 0x550033,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.9
                    });

                    const mallaTexto = new THREE.Mesh(geometriaTexto, materialTexto);

                    // Posici칩n inicial aleatoria alrededor del planeta
                    const distancia = 12 + Math.random() * 8;
                    const angulo = Math.random() * Math.PI * 2;
                    const altura = (Math.random() - 0.5) * 15;

                    mallaTexto.position.set(
                        Math.cos(angulo) * distancia,
                        altura,
                        Math.sin(angulo) * distancia
                    );

                    escena.add(mallaTexto);

                    objetosMensaje.push({
                        malla: mallaTexto,
                        alturaOriginal: altura,
                        velocidad: 0.2 + Math.random() * 0.3,
                        angulo: angulo,
                        distancia: distancia
                    });
                });
            });
        }

        function crearParticulasFlotantes() {
            const geometriaParticulas = new THREE.BufferGeometry();
            const cantidadParticulas = 500;
            const posiciones = new Float32Array(cantidadParticulas * 3);
            const colores = new Float32Array(cantidadParticulas * 3);

            for (let i = 0; i < cantidadParticulas * 3; i += 3) {
                posiciones[i] = (Math.random() - 0.5) * 100;
                posiciones[i + 1] = (Math.random() - 0.5) * 100;
                posiciones[i + 2] = (Math.random() - 0.5) * 100;

                colores[i] = 1;
                colores[i + 1] = Math.random() * 0.5 + 0.4;
                colores[i + 2] = Math.random() * 0.8 + 0.6;
            }

            geometriaParticulas.setAttribute('position', new THREE.BufferAttribute(posiciones, 3));
            geometriaParticulas.setAttribute('color', new THREE.BufferAttribute(colores, 3));

            const materialParticulas = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            const particulas = new THREE.Points(geometriaParticulas, materialParticulas);
            escena.add(particulas);
        }

        function configurarEventos() {
            document.addEventListener('click', manejarInteraccion);
            document.addEventListener('touchstart', manejarInteraccion);
            document.addEventListener('click', mostrarEfectoToque);
            document.addEventListener('touchstart', mostrarEfectoToque);

            document.querySelectorAll('.elemento-galeria').forEach(elemento => {
                elemento.addEventListener('click', abrirModal);
            });

            document.querySelector('.boton-cerrar').addEventListener('click', cerrarModal);
            document.getElementById('alternar-audio').addEventListener('click', alternarAudio);
            window.addEventListener('resize', manejarRedimensionamiento);
        }

        function alternarAudio() {
            audioHabilitado = !audioHabilitado;
            const botonAudio = document.getElementById('alternar-audio');

            if (audioHabilitado) {
                botonAudio.textContent = '游댉';
                botonAudio.style.background = 'rgba(255, 105, 180, 0.3)';
                reproducirAudio();
            } else {
                botonAudio.textContent = '游댆';
                botonAudio.style.background = 'rgba(255, 255, 255, 0.15)';
                pausarAudio();
            }
        }

        function reproducirAudio() {
            const audio = document.getElementById('audio-fondo');
            if (audioHabilitado) {
                audio.play().catch(e => {
                    console.log("Audio requiere interacci칩n del usuario primero.");
                });
            }
        }

        function pausarAudio() {
            const audio = document.getElementById('audio-fondo');
            audio.pause();
        }

        function manejarInteraccion(e) {
            if (e.target.closest('.elemento-galeria') || e.target.closest('.modal') ||
                e.target.closest('#alternar-audio') ||
                document.getElementById('cargando').style.display !== 'none') return;

            if (!audioReproducido) {
                audioHabilitado = true;
                document.getElementById('alternar-audio').textContent = '游댉';
                document.getElementById('alternar-audio').style.background = 'rgba(255, 105, 180, 0.3)';
                reproducirAudio();
                audioReproducido = true;
            }

            crearExplosionTexto(e);
            crearLluviaCorazones();
            contadorToques++;

            if (contadorToques === 5) {
                document.getElementById('instrucciones').textContent = "춰Eres incre칤ble! Cada toque es un latido de mi coraz칩n 仇벒잺";
            } else if (contadorToques === 10) {
                document.getElementById('instrucciones').textContent = "Eres el amor de mi vida 游눘";
            } else if (contadorToques >= 15) {
                const mensajes = [
                    "Mi coraz칩n late por ti",
                    "Eres mi sue침o hecho realidad",
                    "Eres mi todo",
                    "Te amo m치s cada d칤a",
                    "Eres mi raz칩n de ser"
                ];
                document.getElementById('instrucciones').textContent = mensajes[Math.floor(Math.random() * mensajes.length)];
            }
        }

        function crearExplosionTexto(e) {
            const x = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const y = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

            const textosAmor = ["TE AMO", "ERES M칈A", "MI AMOR", "PARA SIEMPRE", "MI VIDA", "MI TODO", "MI CORAZ칍N", "MI ALMA"];
            const textoAleatorio = textosAmor[Math.floor(Math.random() * textosAmor.length)];

            const explosionTexto = document.createElement('div');
            explosionTexto.innerHTML = textoAleatorio;
            explosionTexto.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                font-size: 24px;
                color: #ff69b4;
                font-weight: bold;
                text-shadow: 0 0 10px #ff1493;
                z-index: 20;
                pointer-events: none;
                transform: translate(-50%, -50%);
                animation: animacionExplosionTexto 1.5s ease-out forwards;
            `;

            document.getElementById('superposicion-ui').appendChild(explosionTexto);

            setTimeout(() => {
                if (explosionTexto.parentNode) {
                    explosionTexto.parentNode.removeChild(explosionTexto);
                }
            }, 1500);
        }

        function mostrarEfectoToque(e) {
            if (e.target.closest('.elemento-galeria') || e.target.closest('.modal') ||
                e.target.closest('#alternar-audio') ||
                document.getElementById('cargando').style.display !== 'none') return;

            const indicador = document.getElementById('indicador-toque');
            const x = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const y = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

            indicador.style.left = x + 'px';
            indicador.style.top = y + 'px';
            indicador.style.opacity = '1';

            setTimeout(() => {
                indicador.style.opacity = '0';
            }, 300);
        }

        function crearLluviaCorazones() {
            if (lluviaCorazonesActiva) return;
            lluviaCorazonesActiva = true;

            for (let i = 0; i < 15; i++) {
                setTimeout(() => crearCorazon(), i * 100);
            }

            crearCorazones3D();
            setTimeout(() => { lluviaCorazonesActiva = false; }, 2000);
        }

        function crearCorazon() {
            const corazon = document.createElement('div');
            corazon.innerHTML = '仇벒잺';
            corazon.classList.add('corazon');
            corazon.style.cssText = `
                position: absolute;
                left: ${Math.random() * 100}vw;
                font-size: ${Math.random() * 20 + 18}px;
                animation-duration: ${Math.random() * 2 + 2}s;
            `;

            document.getElementById('superposicion-ui').appendChild(corazon);

            setTimeout(() => {
                if (corazon.parentNode) {
                    corazon.parentNode.removeChild(corazon);
                }
            }, 5000);
        }

        function crearCorazones3D() {
            for (let i = 0; i < 8; i++) {
                const geometriaCorazon = new THREE.SphereGeometry(0.2, 8, 8);
                const materialCorazon = new THREE.MeshPhongMaterial({
                    color: 0xff69b4,
                    emissive: 0x990044,
                    transparent: true,
                    opacity: 0.8
                });

                const corazon = new THREE.Mesh(geometriaCorazon, materialCorazon);
                corazon.position.set(
                    (Math.random() - 0.5) * 20,
                    10 + Math.random() * 5,
                    (Math.random() - 0.5) * 20
                );

                escena.add(corazon);
                animarCorazon3D(corazon);
            }
        }

        function animarCorazon3D(corazon) {
            const velocidadCaida = Math.random() * 0.05 + 0.02;
            const velocidadRotacion = Math.random() * 0.1 + 0.05;

            function animar() {
                corazon.position.y -= velocidadCaida;
                corazon.rotation.x += velocidadRotacion;
                corazon.rotation.z += velocidadRotacion;

                if (corazon.position.y > -10) {
                    requestAnimationFrame(animar);
                } else {
                    escena.remove(corazon);
                }
            }
            animar();
        }

        function abrirModal(e) {
            const indice = parseInt(e.currentTarget.getAttribute('data-indice'));
            const modal = document.getElementById('modal-imagen');
            const mensajeModal = document.getElementById('mensaje-modal');

            mensajeModal.textContent = mensajesImagen[indice];
            modal.style.display = 'flex';
        }

        function cerrarModal() {
            document.getElementById('modal-imagen').style.display = 'none';
        }

        function manejarRedimensionamiento() {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
        }

        function animar() {
            requestAnimationFrame(animar);

            // Rotar Saturno
            if (saturno) {
                saturno.rotation.y += 0.005;
            }

            // Animar texto del anillo
            objetosTextoAnillo.forEach((obj, i) => {
                obj.rotation.y += 0;
                obj.position.y = Math.sin(Date.now() * 0.002 + i * 0.2) * 0.3;

                obj.lookAt(camara.position);
            });

            // Animar mensajes
            const tiempo = Date.now() * 0.001;
            objetosMensaje.forEach((obj, i) => {
                obj.malla.position.y = obj.alturaOriginal + Math.sin(tiempo * obj.velocidad + i) * 2;
                obj.angulo += 0.002 * obj.velocidad;
                obj.malla.position.x = Math.cos(obj.angulo) * obj.distancia;
                obj.malla.position.z = Math.sin(obj.angulo) * obj.distancia;

                obj.malla.lookAt(camara.position);
            });

            // Actualizar posici칩n de la luna CSS seg칰n la c치mara
            actualizarPosicionLuna();

            controles.update();
            renderizador.render(escena, camara);
        }

        function actualizarPosicionLuna() {
            const luna = document.querySelector('.luna');
            if (!luna) return;

            // Crear un vector para la posici칩n de la luna en el espacio 3D
            const posicionLuna3D = new THREE.Vector3(50, 30, -80);

            // Proyectar la posici칩n 3D a coordenadas 2D de la pantalla
            const vectorPantalla = posicionLuna3D.clone();
            vectorPantalla.project(camara);

            // Convertir a coordenadas de p칤xeles
            const x = (vectorPantalla.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vectorPantalla.y * -0.5 + 0.5) * window.innerHeight;

            // Actualizar posici칩n de la luna
            luna.style.left = x + 'px';
            luna.style.top = y + 'px';

            // Opcional: ajustar opacidad si la luna est치 detr치s de la c치mara
            if (vectorPantalla.z > 1) {
                luna.style.opacity = '0.3';
            } else {
                luna.style.opacity = '0.8';
            }
        }

        // Inicializar la aplicaci칩n
        crearEstrellasCSS(100);
        inicializar();
    </script>
</body>
</html>